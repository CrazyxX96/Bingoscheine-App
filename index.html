<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<title>Bingoschein anlegen & prüfen</title>

<!-- OCR -->
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@5.1.0/dist/tesseract.min.js"></script>

<style>
  :root{
    --max-cards: 50;
    --strike-color: #CA3228;
    --accent: #2F4A93;
    --handle:#00BCD4;

    /* Einheitliche, kompaktere Maximalbreite für alle Tabellen */
    --table-max: 520px;
  }

  *{ -webkit-tap-highlight-color:transparent; box-sizing:border-box; }
  body{ font-family:system-ui, Arial, sans-serif; margin:12px; }

  .section-title{
    text-align:center; text-decoration:underline; font-size:20px;
    margin:20px 0 12px; background:#2F4A93; padding:6px 0; border-radius:4px; color:#fff;
  }
  .bar{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; justify-content:center; margin:10px 0; }
  input[type="text"], input[type="number"], input[type="file"], button{
    font-size:16px; padding:10px 12px; border-radius:10px; border:1px solid #ccc;
  }
  button{ background:#f6f6f6; cursor:pointer; }
  button:disabled{ opacity:.5; cursor:not-allowed; }

  .muted{ color:#666; }
  .d-none{ display:none !important; }
  .text-center{ text-align:center; }

  /* Tabellen – Basis (zentriert + max-breite) */
  .table-wrap{
    overflow:hidden; position:relative;
    display:flex; justify-content:center;
    padding:0 8px;
  }
  table{
    border-collapse:collapse;
    width: min(100%, var(--table-max));
    table-layout:fixed;
    margin:0 auto;
  }
  table.saved-card{ width:min(100%, var(--table-max)); }

  th, td{ text-align:center; vertical-align:middle; border:2px solid #444; }
  th{ background:#9DCA43; color:#fff; font-size:20px; height:44px; }
  td{ height:56px; font-size:18px; }

  /* Eingabetabelle */
  #inputTable{ width:min(100%, var(--table-max)); }
  #inputTable td{ background:transparent !important; }
  input.cell-inp{
    width:94%; height:90%; text-align:center;
    font-size:16px; line-height:1.2; padding:2px 4px;
    border:none; outline:none; background:transparent;
    margin:auto; display:block; box-sizing:border-box;
  }
  input.cell-inp::placeholder{ font-size:12px; color:#999; }
  input[type="number"]::-webkit-outer-spin-button,
  input[type="number"]::-webkit-inner-spin-button{ -webkit-appearance:none; margin:0; }
  input[type="number"]{ -moz-appearance:textfield; }

  .invalid-cell{ border:2px solid #c62828 !important; border-radius:6px; }
  #cardName.invalid-cell, #serialNo.invalid-cell, #ticketNo.invalid-cell{ border-color:#c62828 !important; }

  /* Gespeicherte Scheine */
  .cards{ display:flex; flex-direction:column; gap:18px; margin-top:14px; align-items:center; }
  .card-block{ border:1px solid #e2e2e2; border-radius:10px; padding:10px; width: min(100%, var(--table-max)); }
  .card-header{ display:block; text-align:center; }
  .card-title{ font-weight:600; margin-bottom:8px; }
  .card-actions{ display:flex; gap:8px; justify-content:center; margin:6px 0 10px; }
  .badge{ font-weight:700; }
  .count{ text-align:center; margin-top:8px; }
  .empty{ text-align:center; color:#666; padding:12px 0; font-style:italic; }
  .empty button{ margin-top:8px; }
  .saved-card td{ background:#fff; }
  .saved-card td.hit{ background:#ffff00; font-weight:700; }  /* Markierung gelb */

  /* Status & Meldungen */
  .status-bar, #formError, #saveSuccess, #deleteSuccess, #drawError, #successMsg,
  #ocrError, #ocrSuccess { text-align:center; }
  .status-bingo{ background:#ffff00; padding:6px 10px; border-radius:6px; display:inline-block; }
  .status-bar .status-bingo{ background:#ffff00 !important; } /* robust gegen Overrides */
  .status-sub{ font-size:14px; color:#666; margin-top:4px; }

  .spacer-large{ height:40px; }

  /* Bingo-Linien */
  .strike-line{
    position:absolute; height:4px; background:var(--strike-color);
    transform-origin:left center; pointer-events:none; z-index:5;
  }

  /* Gezogene-Zahlen: Bingo-Tabelle (einheitliche Breite + zentriert) */
  .drawn-grid-wrap{ overflow-x:auto; padding:0 8px; display:flex; justify-content:center; }
  #drawnGridTable{
    border-collapse:collapse; margin:0 auto;
    width:min(100%, var(--table-max)); max-width:var(--table-max);
    table-layout:fixed;
  }
  #drawnGridTable th, #drawnGridTable td{ border:2px solid #444; text-align:center; }
  #drawnGridTable th{ background:#000; color:#fff; font-size:20px; height:44px; } /* schwarz */
  #drawnGridTable td{ height:44px; }
  #drawnGridTable .cell-inner{ min-height:36px; display:flex; align-items:center; justify-content:center; }

  .number-badge{ display:inline-block; border-radius:4px; padding:2px 6px; margin:0; font-size:14px; cursor:pointer; user-select:none; }
  .hit-badge{ background:#ffff99; font-weight:600; } /* gelb */
  .miss-badge{ background:#E5E2D9; }                 /* grau */

  /* ===== Foto-Bereich (Beta) ===== */
  #photoZone{ display:flex; flex-direction:column; align-items:center; gap:10px; }
  #photoStage{
    position:relative; max-width:100%; width:min(900px, 100%); aspect-ratio:4/3;
    background:#fafafa; border:1px dashed #bbb; border-radius:8px; overflow:hidden;
    cursor:default; touch-action:none; user-select:none;
  }
  #photoStage.space-pan{ cursor:grab; }
  #photoStage.space-pan.active{ cursor:grabbing; }
  #photoStage img{
    position:absolute; inset:0; width:100%; height:100%; object-fit:contain; pointer-events:none;
    transform-origin:center center; will-change:transform;
  }
  .crop-overlay{ position:absolute; inset:0; pointer-events:none; }
  .crop-rect{
    position:absolute; border:3px solid var(--handle);
    box-shadow:0 0 0 9999px rgba(0,0,0,.35);
    pointer-events:auto; cursor:move; transform-origin:center center; touch-action:none; z-index:10;
  }
  .grid-line{ position:absolute; background:rgba(255,255,255,.75); }
  .handle{
    position:absolute; width:28px; height:28px; background:var(--handle);
    border:2px solid #fff; border-radius:50%; box-shadow:0 1px 4px rgba(0,0,0,.4);
    cursor:grab; touch-action:none; z-index:11;
  }
  .handle:active{ cursor:grabbing; }
  .handle.tl{ transform:translate(-50%,-50%); }
  .handle.tr{ transform:translate(50%,-50%); }
  .handle.bl{ transform:translate(-50%,50%); }
  .handle.br{ transform:translate(50%,50%); }

  .handle.rot{
    width:26px; height:26px; background:#fff; border:3px solid var(--handle);
    border-radius:50%; position:absolute; left:50%; top:-28px; transform:translate(-50%,-50%); cursor:grab;
  }
  .angle-badge{
    position:absolute; left:50%; top:-48px; transform:translate(-50%,-50%);
    background:rgba(47,74,147,.95); color:#fff; font-size:12px; padding:3px 7px; border-radius:6px;
    pointer-events:none; z-index:12;
  }

  .cell-box{
    position:absolute; border:2px dashed rgba(255,255,255,.85); outline:1px solid rgba(0,0,0,.25);
    box-sizing:border-box; pointer-events:none;
  }

  #ocrProgressWrap{ width:min(900px, 100%); margin:0 auto; }
  #ocrProgressBar{ height:10px; background:#e0e0e0; border-radius:6px; overflow:hidden; }
  #ocrProgressBar>div{ height:100%; width:0%; background:var(--accent); transition:width .2s ease; }
  #ocrLegend{ font-size:13px; color:#666; text-align:center; }
  .mobile-rotate{ display:flex; gap:8px; margin-top:6px; justify-content:center; }
  @media (min-width:601px){ .mobile-rotate{ display:none; } }

  /* Zusätzliche Smartphone-Optimierung */
  @media (max-width:380px){
    td { height:52px; }
    input.cell-inp { font-size:15px; height:92%; }
    input.cell-inp::placeholder { font-size:11px; }
  }
</style>
</head>
<body>

<!-- ======================= -->
<!-- A) FOTO-BEREICH (BETA) -->
<!-- ======================= -->
<h2 id="betaTop" class="section-title">Schein mit Foto anlegen (Beta)</h2>
<div id="photoZone" class="bar" style="flex-direction:column">
  <div class="bar">
    <input id="uploadInput" type="file" accept="image/*">
    <button id="alignBtn" class="d-none">📏 Zahlentabelle ausrichten</button>
    <button id="finishAlignBtn" class="d-none">✅ Fertig ausgerichtet</button>
    <button id="deletePhotoBtn" class="d-none">🧹 Foto entfernen</button>
  </div>

  <div id="photoStage" class="d-none" title="Pinch: Zoom • 1-Finger: Bild/Frame ziehen • Kreis oben: drehen">
    <img id="photoImage" alt="Bingoschein">
    <div class="crop-overlay d-none" id="cropOverlay">
      <div id="cropRect" class="crop-rect" style="left:10%; top:10%; width:80%; height:80%;">
        <!-- Grid-Linien -->
        <div class="grid-line" data-grid="v1"></div>
        <div class="grid-line" data-grid="v2"></div>
        <div class="grid-line" data-grid="v3"></div>
        <div class="grid-line" data-grid="v4"></div>
        <div class="grid-line" data-grid="h1"></div>
        <div class="grid-line" data-grid="h2"></div>
        <div class="grid-line" data-grid="h3"></div>
        <div class="grid-line" data-grid="h4"></div>

        <!-- 25 Suchfelder -->
        <div id="cellBoxes"></div>

        <!-- Ecken -->
        <div class="handle tl" data-h="tl"></div>
        <div class="handle tr" data-h="tr"></div>
        <div class="handle bl" data-h="bl"></div>
        <div class="handle br" data-h="br"></div>
        <!-- Dreh-Handle -->
        <div class="handle rot" data-h="rot" title="Drehen"></div>
        <div class="angle-badge" id="angleBadge">0°</div>
      </div>
    </div>
  </div>

  <!-- Mobile Drehhilfe (nur im Zuschnittmodus sichtbar) -->
  <div class="mobile-rotate d-none" id="mobileRotate">
    <button id="rotMinus">↶ −1°</button>
    <button id="rotPlus">↷ +1°</button>
    <button id="rotReset">⟲ 0°</button>
  </div>

  <div id="ocrLegend" class="mt-24">Tipp: Richte so aus, dass jede Zahl mittig in einem Feld liegt. Danach „Fertig ausgerichtet“.</div>

  <div id="ocrProgressWrap" class="d-none">
    <div id="ocrProgressBar"><div></div></div>
    <div id="ocrStatus" class="muted" style="text-align:center; margin-top:6px;">Bereit…</div>
  </div>

  <div id="ocrError"></div>
  <div id="ocrSuccess"></div>
</div>

<!-- ======================= -->
<!-- B) MANUELLER BEREICH -->
<!-- ======================= -->
<h2 id="top" class="section-title">Schein anlegen</h2>

<div class="table-wrap">
  <table id="inputTable" aria-label="Eingabetabelle">
    <thead>
      <tr><th>B</th><th>I</th><th>N</th><th>G</th><th>O</th></tr>
    </thead>
    <tbody id="inputBody">
      <script>
        const COL_RANGES_INPUT = [[1,15],[16,30],[31,45],[46,60],[61,75]];
        document.write(
          Array(5).fill('').map(() =>
            '<tr>' + COL_RANGES_INPUT.map(([min,max]) =>
              `<td><input class="cell-inp" type="number" min="${min}" max="${max}" step="1" placeholder="${min}-${max}"></td>`
            ).join('') + '</tr>'
          ).join('')
        );
      </script>
    </tbody>
  </table>
</div>

<div class="bar">
  <input id="cardName"  type="text" placeholder="Scheinname (z.B. Schein 1)">
  <input id="serialNo"  type="text" placeholder="Seriennummer (optional)">
  <input id="ticketNo"  type="text" placeholder="Losnummer (optional)">
</div>

<div class="bar">
  <button id="saveBtn">💾 Schein speichern</button>
  <button id="saveCancelBtn" class="d-none">✖️ Abbrechen</button>
  <button id="clearBtn">♻️ Alles zurücksetzen</button>
</div>
<div id="formError"></div>
<div id="saveSuccess"></div>
<div class="count muted" id="countInfo">Gespeicherte Scheine: 0 / 50</div>

<!-- ======================= -->
<!-- C) PRÜFEN -->
<!-- ======================= -->
<div class="spacer-large"></div>
<h2 class="section-title">Gezogene Zahlen eintragen & prüfen</h2>

<div class="bar">
  <label for="drawn">Gezogene Zahl(en):</label>
  <input id="drawn" type="text" placeholder="z.B.16,22,37">
</div>

<div class="bar">
  <button id="markBtn">🔍 Jetzt prüfen</button>
  <button id="resetMarksBtn">🔄 Zahlen zurücksetzen</button>
</div>

<!-- Status direkt unter den Buttons -->
<div class="status-bar" id="status">Noch kein Bingo<br><div class="status-sub">(Prüfung läuft über alle gespeicherten Scheine)</div></div>

<div id="drawError"></div>
<div id="successMsg"></div>

<div class="marked-list text-center" id="drawnList" style="margin-top:24px;">Gezogene Zahlen (0): –</div>

<!-- Gezogene Zahlen als Bingo-Tabelle -->
<div class="drawn-grid-wrap" id="drawnGridWrap" style="margin-top:24px;">
  <table id="drawnGridTable" aria-label="Gezogene Zahlen als Bingo-Tabelle">
    <thead>
      <tr><th>B</th><th>I</th><th>N</th><th>G</th><th>O</th></tr>
    </thead>
    <tbody id="drawnGridBody">
      <tr><td colspan="5"><div class="cell-inner muted">– keine Zahlen –</div></td></tr>
    </tbody>
  </table>
</div>

<!-- Legende -->
<div class="bar" style="margin-top:24px;">
  <button id="toggleLegendBtn" aria-expanded="false" class="d-none">Legende anzeigen</button>
</div>
<div id="legend" class="muted text-center d-none" style="margin-top:24px;">
  <span class="number-badge hit-badge"  style="color:transparent;">&nbsp;&nbsp;&nbsp;</span>
  = Zahl ist auf mindestens einem gespeicherten Schein vorhanden<br>
  <span class="number-badge miss-badge" style="color:transparent;">&nbsp;&nbsp;&nbsp;</span>
  = Zahl ist auf keinem gespeicherten Schein vorhanden
</div>

<!-- ======================= -->
<!-- D) LISTE -->
<!-- ======================= -->
<div class="spacer-large"></div>
<h2 class="section-title">Gespeicherte Scheine</h2>
<div class="bar">
  <button id="deleteAllBtn" class="d-none">🗑️ Alle Scheine löschen</button>
</div>
<div id="deleteSuccess"></div>
<div class="cards" id="cards"></div>

<!-- ======================= -->
<!-- E) APP-LOGIK -->
<!-- ======================= -->
<script>
(function(){
  const STORAGE_KEY='gb-bingo-v78';
  const MAX_CARDS=50;
  const COL_RANGES=[[1,15],[16,30],[31,45],[46,60],[61,75]];

  /* ========= Elemente ========= */
  const cardName = document.getElementById('cardName');
  const serialNo = document.getElementById('serialNo');
  const ticketNo = document.getElementById('ticketNo');
  const inputBody = document.getElementById('inputBody');
  const saveBtn = document.getElementById('saveBtn');
  const saveCancelBtn = document.getElementById('saveCancelBtn');
  const clearBtn = document.getElementById('clearBtn');
  const cardsWrap = document.getElementById('cards');
  const countInfo = document.getElementById('countInfo');

  const drawn   = document.getElementById('drawn');
  const markBtn = document.getElementById('markBtn');
  const resetBtn= document.getElementById('resetMarksBtn');

  const status  = document.getElementById('status');

  const formError = document.getElementById('formError');
  const drawError = document.getElementById('drawError');
  const successBox= document.getElementById('successMsg');
  const saveSuccess = document.getElementById('saveSuccess');
  const deleteSuccess = document.getElementById('deleteSuccess');
  const deleteAllBtn = document.getElementById('deleteAllBtn');

  const drawnList   = document.getElementById('drawnList');
  const drawnGridBody = document.getElementById('drawnGridBody');

  const legend = document.getElementById('legend');
  const toggleLegendBtn = document.getElementById('toggleLegendBtn');

  // Foto/OCR
  const uploadInput = document.getElementById('uploadInput');
  const alignBtn = document.getElementById('alignBtn');
  const finishAlignBtn = document.getElementById('finishAlignBtn');
  const deletePhotoBtn = document.getElementById('deletePhotoBtn');
  const photoStage = document.getElementById('photoStage');
  const photoImage = document.getElementById('photoImage');
  const cropOverlay = document.getElementById('cropOverlay');
  const cropRect = document.getElementById('cropRect');
  const angleBadge = document.getElementById('angleBadge');
  const ocrProgressWrap = document.getElementById('ocrProgressWrap');
  const ocrProgressBar = document.getElementById('ocrProgressBar').firstElementChild;
  const ocrStatus = document.getElementById('ocrStatus');
  const ocrError = document.getElementById('ocrError');
  const ocrSuccess = document.getElementById('ocrSuccess');

  const rotMinus = document.getElementById('rotMinus');
  const rotPlus  = document.getElementById('rotPlus');
  const rotReset = document.getElementById('rotReset');
  const mobileRotate = document.getElementById('mobileRotate');

  /* ========= Utilities ========= */
  function show(el){ el.classList.remove('d-none'); }
  function hide(el){ el.classList.add('d-none'); }
  function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }
  function isSmall(){ return window.matchMedia('(max-width: 600px)').matches; }

  /* ========= State ========= */
  let allDrawnNumbers=[]; // Strings
  let editIndex = null;

  // Foto-Interaktion
  let currentObjectURL=null, hasImage=false, alignActive=false;
  let imgScale=1, imgOffset={x:0, y:0}, cropAngleDeg=0;
  const MIN_SCALE=0.5, MAX_SCALE=4;
  let dragMode=null, dragStart=null;
  const activePointers = new Map();
  let spaceDown=false;

  /* ========= Storage ========= */
  function loadAll(){ try{ return JSON.parse(localStorage.getItem(STORAGE_KEY))||[] }catch(e){ return [] } }
  function saveAll(arr){ localStorage.setItem(STORAGE_KEY, JSON.stringify(arr)); }

  /* ========= Eingabe-Helfer ========= */
  function getInputs(){ return Array.from(inputBody.querySelectorAll('input.cell-inp')); }
  function readNumbers(){ return getInputs().map(i => (i.value||'').trim()); }
  function clearInput(){
    getInputs().forEach(i=>i.value=''); cardName.value=''; serialNo.value=''; ticketNo.value='';
    formError.textContent=''; liveValidate();
  }
  function hasDup(a){ const v=a.filter(x=>x!==''); return new Set(v).size!==v.length; }

  function liveValidate(){
    const inputs=getInputs(), values=inputs.map(i=>(i.value||'').trim());
    inputs.forEach(i=>i.classList.remove('invalid-cell'));
    values.forEach((v,i)=>{ const [min,max]=COL_RANGES[i%5]; const n=Number(v);
      if(v!=='' && (Number.isNaN(n) || !Number.isInteger(n) || n<min || n>max)){ inputs[i].classList.add('invalid-cell'); }
    });
    const seen=new Map();
    values.forEach((val,idx)=>{ if(val==='')return;
      if(seen.has(val)){ inputs[idx].classList.add('invalid-cell'); inputs[seen.get(val)].classList.add('invalid-cell'); }
      else seen.set(val,idx);
    });
  }

  function validate(nums){
    const errs=[];
    nums.forEach((v,i)=>{ const [min,max]=COL_RANGES[i%5]; const n=Number(v);
      if(v===''||Number.isNaN(n)||!Number.isInteger(n)||n<min||n>max){
        errs.push('E'); const inp=getInputs()[i];
        if(inp){ inp.classList.add('invalid-cell'); setTimeout(()=>inp.classList.remove('invalid-cell'),1500); }
      }
    });
    const seen=new Map();
    nums.forEach((val,idx)=>{ if(val==='')return;
      if(seen.has(val)){
        const ins=getInputs(); ins[idx].classList.add('invalid-cell'); ins[seen.get(val)].classList.add('invalid-cell');
        setTimeout(()=>{ins[idx].classList.remove('invalid-cell'); ins[seen.get(val)].classList.remove('invalid-cell');},1500);
        if(!errs.includes('DUP')) errs.push('DUP');
      } else seen.set(val,idx);
    });
    return errs.filter(x=>x!=='DUP');
  }

  function fadeOK(el, text){
    el.textContent = text; el.style.opacity = '1';
    setTimeout(()=>{ el.style.opacity = '0'; setTimeout(()=>{ el.textContent=''; }, 500); }, 2000);
  }

  /* ===== Datenbasierte Trefferprüfung ===== */
  function existsInAnyCardData(numStr){
    const d=loadAll(); const n=Number(numStr);
    if(!Number.isInteger(n)) return false;
    for(const c of d){
      if(c && Array.isArray(c.numbers) && c.numbers.includes(String(n))) return true;
    }
    return false;
  }

  /* ========= Karten-Rendering & Bingo-Linien ========= */
  function renderAllCards(){
    const d=loadAll(); cardsWrap.innerHTML='';
    deleteAllBtn.classList.toggle('d-none', d.length===0);

    if(d.length===0){
      const empty=document.createElement('div');
      empty.className='empty';
      empty.innerHTML='Keine Scheine gespeichert<br><button id="gotoTop">Jetzt Schein anlegen</button>';
      cardsWrap.appendChild(empty);
      const go = document.getElementById('gotoTop');
      if(go){ go.addEventListener('click',()=>{ document.getElementById('top').scrollIntoView({behavior:"smooth"}); }); }
    }else{
      d.forEach((c,i)=>{
        const wrap=document.createElement('div');
        wrap.className='card-block';

        const header=document.createElement('div'); header.className='card-header';
        const title=document.createElement('div'); title.className='card-title';
        const parts=[`#${i+1} – ${c.name||'Unbenannt'}`]; if(c.serialNo) parts.push(`Serie: ${c.serialNo}`); if(c.ticketNo) parts.push(`Los: ${c.ticketNo}`);
        title.textContent=parts.join(' • ');
        header.appendChild(title);

        const actions=document.createElement('div'); actions.className='card-actions';
        const edit=document.createElement('button'); edit.textContent='✏️ Bearbeiten'; edit.dataset.act='edit'; edit.dataset.idx=i;
        const del=document.createElement('button'); del.textContent='🗑️ Löschen'; del.dataset.act='delete'; del.dataset.idx=i;
        actions.appendChild(edit); actions.appendChild(del);

        wrap.appendChild(header);
        wrap.appendChild(actions);

        const tw=document.createElement('div'); tw.className='table-wrap';
        const t=document.createElement('table'); t.classList.add('saved-card');
        const thead=document.createElement('thead'); thead.innerHTML='<tr><th>B</th><th>I</th><th>N</th><th>G</th><th>O</th></tr>';
        const tb=document.createElement('tbody');
        for(let r=0;r<5;r++){
          const tr=document.createElement('tr');
          for(let c2=0;c2<5;c2++){
            const val = c.numbers[r*5+c2]||'';
            const td=document.createElement('td');
            td.textContent = val;
            td.dataset.num = String(val);  /* für zuverlässiges Matching */
            tr.appendChild(td);
          }
          tb.appendChild(tr);
        }
        t.appendChild(thead); t.appendChild(tb); tw.appendChild(t); wrap.appendChild(tw);
        cardsWrap.appendChild(wrap);
      });
    }
    countInfo.textContent=`Gespeicherte Scheine: ${d.length} / ${MAX_CARDS}`;

    applyHitsFromDrawnNumbers();
    updateAll();
    updateUnifiedList();
  }

  function lineSets(tb){
    const rows=Array.from(tb.querySelectorAll('tr')); const sets=[];
    for(let r=0;r<5;r++){ sets.push([0,1,2,3,4].map(c=>rows[r].children[c])); }
    for(let c=0;c<5;c++){ sets.push([0,1,2,3,4].map(r=>rows[r].children[c])); }
    sets.push([0,1,2,3,4].map(i=>rows[i].children[i]));
    sets.push([0,1,2,3,4].map(i=>rows[i].children[4-i]));
    return sets;
  }
  function drawLine(container, cells){
    const f=cells[0].getBoundingClientRect(), l=cells[cells.length-1].getBoundingClientRect(), ct=container.getBoundingClientRect();
    const x1=(f.left+f.width/2)-ct.left+container.scrollLeft, y1=(f.top+f.height/2)-ct.top+container.scrollTop;
    const x2=(l.left+l.width/2)-ct.left+container.scrollLeft, y2=(l.top+l.height/2)-ct.top+container.scrollTop;
    const dx=x2-x1, dy=y2-y1, len=Math.hypot(dx,dy), ang=Math.atan2(dy,dx);
    const line=document.createElement('div'); line.className='strike-line';
    line.style.left=`${x1}px`; line.style.top=`${y1-2}px`; line.style.width=`${len}px`; line.style.transform=`rotate(${ang}rad)`;
    container.appendChild(line);
  }
  function remLines(container){ container.querySelectorAll('.strike-line').forEach(e=>e.remove()); }

  function countWins(tw){
    const tb=tw.querySelector('tbody'); remLines(tw); let w=0;
    lineSets(tb).forEach(cs=>{ if(cs.every(td=>td.classList.contains('hit'))){ w++; drawLine(tw,cs); } });
    return w;
  }

  function updateAll(){
    const wraps=Array.from(cardsWrap.children); let maxW=0;
    wraps.forEach((w)=>{
      const tw=w.querySelector('.table-wrap'); if(!tw) return;
      const wins = countWins(tw); if(wins>maxW) maxW=wins;
    });
    if(maxW>0){
      const txt = ['Bingo!','Doppelbingo!!','Dreifachbingo!!!','Vierfachbingo!!!!','Fünffachbingo!!!!!'][maxW-1] || 'Bingo!';
      status.innerHTML = `<div class="status-bingo">🎉 Mindestens ein Schein hat ein ${txt} 🎉</div>`;
    }else{
      status.innerHTML = 'Noch kein Bingo<br><div class="status-sub">(Prüfung läuft über alle gespeicherten Scheine)</div>';
    }
  }

  /* ========= Markierungen erneut anwenden ========= */
  function applyHitsFromDrawnNumbers(){
    cardsWrap.querySelectorAll('.saved-card td.hit').forEach(td=>td.classList.remove('hit'));
    for(const numStr of allDrawnNumbers){ setHitForNumber(numStr, true); }
  }

  /* ========= Speichern / Bearbeiten ========= */
  function enterEditMode(index){
    const d = loadAll();
    const card = d[index];
    if(!card) return;

    const inputs=getInputs();
    inputs.forEach((inp,j)=>{ inp.value=card.numbers[j]||''; });
    cardName.value=card.name||'';
    serialNo.value=card.serialNo||'';
    ticketNo.value=card.ticketNo||'';
    liveValidate();

    editIndex = index;
    saveBtn.textContent = '💾 Änderungen speichern';
    show(saveCancelBtn);

    document.getElementById('top').scrollIntoView({behavior:'smooth', block:'start'});
  }

  function exitEditMode(){
    editIndex = null;
    saveBtn.textContent = '💾 Schein speichern';
    hide(saveCancelBtn);
  }

  function saveCard(){
    formError.textContent=''; saveSuccess.textContent=''; saveSuccess.style.opacity='0';

    const name=cardName.value.trim();
    if(!name){
      formError.textContent='❌ Bitte einen Scheinnamen eingeben.';
      cardName.classList.add('invalid-cell');
      cardName.scrollIntoView({behavior:'smooth', block:'center'});
      cardName.focus();
      setTimeout(()=>cardName.classList.remove('invalid-cell'),1500);
      return;
    }

    const nums=readNumbers();
    liveValidate();
    const errs=validate(nums);
    if(errs.length){ formError.textContent='❌ Bitte alle 25 Felder korrekt füllen.'; return; }
    if(hasDup(nums)){ formError.textContent='❌ Keine doppelten Zahlen pro Schein erlaubt.'; return; }

    const d=loadAll();
    const payload = { name, serialNo:serialNo.value.trim(), ticketNo:ticketNo.value.trim(), numbers:nums };

    if(editIndex!==null){
      if(!d[editIndex]){ formError.textContent='❌ Schein nicht mehr vorhanden.'; exitEditMode(); return; }
      d[editIndex] = payload; 
      saveAll(d); 
      renderAllCards(); 
      exitEditMode();
      clearInput(); // Eingabe nach "Änderungen speichern" leeren
      fadeOK(saveSuccess, '✔️ Schein aktualisiert.');
    }else{
      if(d.length>=MAX_CARDS){ formError.textContent='❌ Limit erreicht.'; return; }
      d.push(payload); saveAll(d); renderAllCards();
      clearInput(); // Eingabe nach NEU speichern leeren
      fadeOK(saveSuccess, '✔️ Schein gespeichert.');
    }
  }

  /* ========= DOM-gestützte Treffer ========= */
  function setHitForNumber(numStr, on){
    const target = String(numStr);
    cardsWrap.querySelectorAll('table.saved-card').forEach(t=>{
      t.querySelectorAll('tbody td').forEach(td=>{
        if((td.dataset.num||'').trim()===target){
          if(on){ td.classList.add('hit'); } else { td.classList.remove('hit'); }
        }
      });
    });
  }

  /* ========= Gezogene Zahlen ========= */
  function renderDrawnGrid(){
    const cols=[[],[],[],[],[]];
    for(const s of allDrawnNumbers){
      const n = parseInt(s,10);
      if(!Number.isInteger(n)) continue;
      if(n>=1 && n<=15) cols[0].push(n);
      else if(n<=30) cols[1].push(n);
      else if(n<=45) cols[2].push(n);
      else if(n<=60) cols[3].push(n);
      else if(n<=75) cols[4].push(n);
    }
    cols.forEach(c=>c.sort((a,b)=>a-b));
    const rows=Math.max(...cols.map(c=>c.length),0);

    const makeCell = (val)=>{
      if(val==null) return '<td><div class="cell-inner">&nbsp;</div></td>';
      const hit = existsInAnyCardData(String(val));
      const cls = hit ? 'hit-badge' : 'miss-badge';
      return `<td><div class="cell-inner"><span class="number-badge ${cls}" data-num="${val}" data-hit="${hit?'true':'false'}" title="Klicken zum Entfernen">${val}</span></div></td>`;
    };

    let html='';
    for(let r=0;r<rows;r++){
      html+='<tr>';
      for(let c=0;c<5;c++){ html+=makeCell(cols[c][r] ?? null); }
      html+='</tr>';
    }
    if(rows===0){
      html = '<tr><td colspan="5"><div class="cell-inner muted">– keine Zahlen –</div></td></tr>';
    }
    drawnGridBody.innerHTML = html;
    drawnList.textContent = `Gezogene Zahlen (${allDrawnNumbers.length}):`;
  }

  /* ===== Legende ===== */
  function setLegendVisible(on){
    if(on){
      legend.classList.remove('d-none');
      toggleLegendBtn.textContent='Legende ausblenden';
      toggleLegendBtn.setAttribute('aria-expanded','true');
    }else{
      legend.classList.add('d-none');
      toggleLegendBtn.textContent='Legende anzeigen';
      toggleLegendBtn.setAttribute('aria-expanded','false');
    }
  }
  toggleLegendBtn.addEventListener('click', ()=>{
    setLegendVisible( legend.classList.contains('d-none') );
  });

  function updateLegendButtonVisibility(){
    if(allDrawnNumbers.length===0){
      setLegendVisible(false);
      hide(toggleLegendBtn);
    }else{
      show(toggleLegendBtn);
    }
  }

  function updateUnifiedList(){
    if(!allDrawnNumbers.length){
      drawnList.textContent = 'Gezogene Zahlen (0): –';
      drawnGridBody.innerHTML = '<tr><td colspan="5"><div class="cell-inner muted">– keine Zahlen –</div></td></tr>';
      updateLegendButtonVisibility();
      return;
    }
    renderDrawnGrid();
    updateLegendButtonVisibility();
  }

  function markNumber(){
    drawError.textContent=''; successBox.textContent=''; successBox.style.opacity='0';
    const raw = (drawn.value||'').split(/[,\s]+/).map(v=>v.trim()).filter(Boolean);
    const seen = new Set(); const validNums = [];
    for(const v of raw){
      const n = Number(v);
      if(Number.isInteger(n) && n>=1 && n<=75){
        const s = String(n); if(!seen.has(s)){ seen.add(s); validNums.push(s); }
      }
    }
    if(validNums.length===0){
      drawError.textContent='❌ Bitte nur ganze Zahlen zwischen 1 und 75 eingeben.';
      drawn.focus(); return;
    }

    let anyHit=false;
    for(const numStr of validNums){
      if(!allDrawnNumbers.includes(numStr)) allDrawnNumbers.push(numStr);
      if(existsInAnyCardData(numStr)){ anyHit=true; }
    }

    applyHitsFromDrawnNumbers();
    updateUnifiedList();
    updateAll();

    if(anyHit){ fadeOK(successBox, '✔️ Zahl(en) markiert.'); }
    else{
      const last = validNums[validNums.length-1];
      drawError.textContent = `ℹ️ Zahl ${last} ist auf keinem gespeicherten Schein vorhanden.`;
    }

    drawn.value=''; drawn.focus();
  }

  function resetMarks(){
    drawError.textContent='';
    cardsWrap.querySelectorAll('.saved-card td.hit').forEach(td=>td.classList.remove('hit'));
    cardsWrap.querySelectorAll('.table-wrap').forEach(remLines);
    allDrawnNumbers=[];
    updateUnifiedList();
    status.innerHTML = 'Noch kein Bingo<br><div class="status-sub">(Prüfung läuft über alle gespeicherten Scheine)</div>';
    fadeOK(successBox, '✔️ Zahlen zurückgesetzt.');
  }

  // Entfernen per Klick (aus Gezogene-Zahlen-Tabelle)
  document.addEventListener('click', (e)=>{
    const badge = e.target.closest('.number-badge'); 
    if(!badge) return;
    const numStr = badge.dataset.num;
    allDrawnNumbers = allDrawnNumbers.filter(n => n !== numStr);
    applyHitsFromDrawnNumbers();
    cardsWrap.querySelectorAll('.table-wrap').forEach(remLines);
    updateUnifiedList();
    updateAll();
  });

  /* ========= Karten-Aktionen ========= */
  cardsWrap.addEventListener('click',e=>{
    const btn=e.target.closest('button'); if(!btn) return;
    const idx=+btn.dataset.idx; const d=loadAll();
    if(btn.dataset.act==='delete'){
      if(!d[idx]) return;
      if(!confirm(`Schein „${d[idx].name}“ löschen?`)) return;
      d.splice(idx,1); saveAll(d);
      renderAllCards();
      fadeOK(deleteSuccess, '✔️ Schein gelöscht.');
      if(editIndex===idx) exitEditMode();
    }
    if(btn.dataset.act==='edit'){
      if(!d[idx]) return;
      enterEditMode(idx);
    }
  });

  deleteAllBtn.addEventListener('click', ()=>{
    const d = loadAll();
    if(d.length===0){ alert("Es sind keine Scheine gespeichert."); return; }
    if(confirm("Wirklich ALLE gespeicherten Scheine löschen?")){
      localStorage.removeItem(STORAGE_KEY);
      renderAllCards();
      allDrawnNumbers=[];
      updateUnifiedList();
      status.innerHTML = 'Noch kein Bingo<br><div class="status-sub">(Prüfung läuft über alle gespeicherten Scheine)</div>';
      fadeOK(deleteSuccess, '✔️ Alle Scheine gelöscht.');
      exitEditMode();
      clearInput();
    }
  });

  /* ========= FOTO / OCR ========= */
  function toggleMobileRotate(){ isSmall() && alignActive ? show(mobileRotate) : hide(mobileRotate); }

  function updatePhotoButtons(){
    if(!hasImage){
      hide(alignBtn); hide(finishAlignBtn); hide(deletePhotoBtn); hide(mobileRotate);
      alignBtn.disabled = finishAlignBtn.disabled = deletePhotoBtn.disabled = true;
      return;
    }
    deletePhotoBtn.disabled = false; show(deletePhotoBtn);
    if(alignActive){
      hide(alignBtn); show(finishAlignBtn); finishAlignBtn.disabled = false;
      toggleMobileRotate();
    }else{
      show(alignBtn); alignBtn.disabled = false;
      hide(finishAlignBtn); finishAlignBtn.disabled = true;
      hide(mobileRotate);
    }
  }

  function enableAlignUI(on){
    alignActive = !!on;
    if(on){ cropOverlay.classList.remove('d-none'); } else { cropOverlay.classList.add('d-none'); }
    updatePhotoButtons();
  }

  function applyImgTransform(){
    photoImage.style.transform = `translate(${imgOffset.x}px, ${imgOffset.y}px) scale(${imgScale})`;
  }
  function applyCropTransform(){
    cropRect.style.transform = `rotate(${cropAngleDeg}deg)`;
    angleBadge.textContent = `${Math.round(cropAngleDeg)}°`;
  }

  function resetPhoto(){
    if(currentObjectURL){ URL.revokeObjectURL(currentObjectURL); currentObjectURL=null; }
    photoImage.src=''; hasImage=false;
    photoStage.classList.add('d-none'); enableAlignUI(false);
    imgScale=1; imgOffset={x:0,y:0}; applyImgTransform();
    cropRect.style.left='10%'; cropRect.style.top='10%'; cropRect.style.width='80%'; cropRect.style.height='80%';
    cropAngleDeg=0; applyCropTransform();
    ocrProgressWrap.classList.add('d-none'); ocrProgressBar.style.width='0%'; ocrStatus.textContent='Bereit…';
    updatePhotoButtons();
  }

  uploadInput.addEventListener('change', (e)=>{
    const file=e.target.files && e.target.files[0];
    if(!file){ resetPhoto(); return; }
    if(currentObjectURL){ URL.revokeObjectURL(currentObjectURL); currentObjectURL=null; }
    const url=URL.createObjectURL(file);
    currentObjectURL = url;
    photoImage.src=url;
    hasImage=true;
    photoStage.classList.remove('d-none');
    enableAlignUI(false); // Auto-Start AUS
    imgScale=1; imgOffset={x:0,y:0}; cropAngleDeg=0; applyImgTransform(); applyCropTransform();
    photoImage.onload=()=>{ updateGrid(); };
    updatePhotoButtons();
  });

  deletePhotoBtn.addEventListener('click', resetPhoto);
  alignBtn.addEventListener('click', ()=>{ if(!hasImage) return; enableAlignUI(true); updateGrid(); document.getElementById('betaTop').scrollIntoView({behavior:'smooth', block:'start'}); });
  finishAlignBtn.addEventListener('click', runOCRPipeline);

  function stylesToPxOnStage(){
    const stageRect = photoStage.getBoundingClientRect();
    const pL = parseFloat(cropRect.style.left)||0;
    const pT = parseFloat(cropRect.style.top)||0;
    const pW = parseFloat(cropRect.style.width)||0;
    const pH = parseFloat(cropRect.style.height)||0;
    const L = stageRect.width*(pL/100);
    const T = stageRect.height*(pT/100);
    const W = stageRect.width*(pW/100);
    const H = stageRect.height*(pH/100);
    return { L,T,W,H, stageRect };
  }
  function writePxAsPercent(L,T,W,H,stageRect){
    cropRect.style.left   = (L/stageRect.width)*100 + '%';
    cropRect.style.top    = (T/stageRect.height)*100 + '%';
    cropRect.style.width  = (W/stageRect.width)*100 + '%';
    cropRect.style.height = (H/stageRect.height)*100 + '%';
  }
  function getBaseContainRect(){
    const stageRect = photoStage.getBoundingClientRect();
    const imgAspect = photoImage.naturalWidth / photoImage.naturalHeight;
    const stageAspect = stageRect.width / stageRect.height;
    let visW, visH, offX, offY;
    if(imgAspect > stageAspect){
      visW = stageRect.width; visH = stageRect.width / imgAspect;
      offX = 0; offY = (stageRect.height - visH)/2;
    }else{
      visH = stageRect.height; visW = stageRect.height * imgAspect;
      offY = 0; offX = (stageRect.width - visW)/2;
    }
    return { left:offX, top:offY, width:visW, height:visH };
  }

  (function ensureCellBoxes(){
    const holder=document.getElementById('cellBoxes');
    if(holder.childElementCount===25) return;
    for(let i=0;i<25;i++){ const box=document.createElement('div'); box.className='cell-box'; holder.appendChild(box); }
  })();

  function updateGrid(){
    const { W,H } = stylesToPxOnStage();
    for(let i=1;i<=4;i++){
      const vx=(W/5)*i; cropRect.querySelector(`[data-grid="v${i}"]`).style.cssText=`left:${vx}px;top:0;width:2px;height:${H}px`;
      const hy=(H/5)*i; cropRect.querySelector(`[data-grid="h${i}"]`).style.cssText=`top:${hy}px;left:0;height:2px;width:${W}px`;
    }
    const boxes=document.getElementById('cellBoxes').children;
    const cw=W/5, ch=H/5;
    for(let r=0;r<5;r++){
      for(let c=0;c<5;c++){
        const idx=r*5+c, bx=boxes[idx];
        bx.style.left=(c*cw)+'px'; bx.style.top=(r*ch)+'px'; bx.style.width=cw+'px'; bx.style.height=ch+'px';
      }
    }
    cropRect.querySelector('.handle.tl').style.cssText='left:0;top:0';
    cropRect.querySelector('.handle.tr').style.cssText=`left:${W}px;top:0`;
    cropRect.querySelector('.handle.bl').style.cssText=`left:0;top:${H}px`;
    cropRect.querySelector('.handle.br').style.cssText=`left:${W}px;top:${H}px`;
  }

  function onPointerDown(e){
    if(!hasImage) return;
    const handle = e.target.closest('.handle');
    if(handle){
      const ht = handle.dataset.h;
      if(ht==='rot'){
        dragMode='rotate';
        const { L,T,W,H } = stylesToPxOnStage();
        dragStart = { cx:L+W/2, cy:T+H/2 };
      }else{
        dragMode='handle:'+ht;
        const s=stylesToPxOnStage();
        dragStart = { ...s, mx:e.clientX, my:e.clientY };
      }
    }else if(e.target === cropRect){
      dragMode='moveRect';
      const s=stylesToPxOnStage();
      dragStart = { ...s, mx:e.clientX, my:e.clientY };
    }else if(e.currentTarget===photoStage){
      dragMode='stage';
    }
    e.preventDefault(); e.stopPropagation();
    e.target.setPointerCapture?.(e.pointerId);
    activePointers.set(e.pointerId, { x:e.clientX, y:e.clientY });
  }

  function onPointerMove(e){
    if(!hasImage) return;
    if(!activePointers.has(e.pointerId)) return;
    activePointers.set(e.pointerId, { x:e.clientX, y:e.clientY });

    const { L:curL, T:curT, W:curW, H:curH, stageRect } = stylesToPxOnStage();

    // Pinch Zoom
    if(dragMode==='stage' && activePointers.size>=2){
      const pts=[...activePointers.values()];
      const [p1,p2]=pts;
      if(!dragStart || !dragStart.pinch){
        dragStart = { pinch:{
          dist: Math.hypot(p2.x-p1.x, p2.y-p1.y),
          scale0: imgScale,
          mid0: { x:(p1.x+p2.x)/2, y:(p1.y+p2.y)/2 },
          off0: { ...imgOffset }
        }};
        return;
      }
      const dist=Math.hypot(p2.x-p1.x, p2.y-p1.y);
      const factor=dist/dragStart.pinch.dist;
      const newScale=clamp(dragStart.pinch.scale0*factor, MIN_SCALE, MAX_SCALE);

      const base=getBaseContainRect();
      const cx=dragStart.pinch.mid0.x - photoStage.getBoundingClientRect().left;
      const cy=dragStart.pinch.mid0.y - photoStage.getBoundingClientRect().top;
      const centerX = base.left + base.width/2;
      const centerY = base.top  + base.height/2;
      const px=cx-centerX, py=cy-centerY;

      const k=newScale/imgScale;
      imgOffset.x = dragStart.pinch.off0.x + px*(1-k);
      imgOffset.y = dragStart.pinch.off0.y + py*(1-k);
      imgScale=newScale;
      applyImgTransform();
      return;
    }

    // Ein-Finger Pan
    if(dragMode==='stage' && activePointers.size===1 && !spaceDown){
      const p = activePointers.get(e.pointerId);
      if(!dragStart || !dragStart.pan){
        dragStart = { pan:{ mx:p.x, my:p.y, ox:imgOffset.x, oy:imgOffset.y } };
        return;
      }
      const dx=p.x-dragStart.pan.mx, dy=p.y-dragStart.pan.my;
      imgOffset.x = dragStart.pan.ox + dx;
      imgOffset.y = dragStart.pan.oy + dy;
      applyImgTransform();
      return;
    }

    // Drehen
    if(dragMode==='rotate'){
      const x = Math.max(0, Math.min(e.clientX - stageRect.left, stageRect.width));
      const y = Math.max(0, Math.min(e.clientY - stageRect.top , stageRect.height));
      const ang1 = Math.atan2(y - (curT+curH/2), x - (curL+curW/2)) * 180/Math.PI;
      const delta = ang1 + 90;
      cropAngleDeg = Math.max(-45, Math.min(45, delta));
      applyCropTransform();
      return;
    }

    // Ecken ziehen
    if(dragMode && dragMode.startsWith('handle:')){
      const mx = Math.max(0, Math.min(e.clientX - stageRect.left, stageRect.width));
      const my = Math.max(0, Math.min(e.clientY - stageRect.top , stageRect.height));
      let L=curL, T=curT, W=curW, H=curH;
      const minSize=40;
      const which=dragMode.split(':')[1];
      if(which==='tl'){
        const newL = Math.max(0, Math.min(mx, curL+curW-minSize));
        const newT = Math.max(0, Math.min(my, curT+curH-minSize));
        W = (curL+curW)-newL; H = (curT+curH)-newT; L=newL; T=newT;
      }else if(which==='tr'){
        const newR = Math.max(curL+minSize, Math.min(mx, stageRect.width));
        W = newR - curL;
        const newT = Math.max(0, Math.min(my, curT+curH-minSize));
        H = (curT+curH)-newT; T=newT;
      }else if(which==='bl'){
        const newB = Math.max(curT+minSize, Math.min(my, stageRect.height));
        H = newB - curT;
        const newL = Math.max(0, Math.min(mx, curL+curW-minSize));
        W = (curL+curW)-newL; L=newL;
      }else if(which==='br'){
        const newR = Math.max(curL+minSize, Math.min(mx, stageRect.width));
        const newB = Math.max(curT+minSize, Math.min(my, stageRect.height));
        W = newR - curL; H = newB - curT;
      }
      writePxAsPercent(L,T,W,H,stageRect);
      updateGrid();
      return;
    }

    // Gesamtrahmen verschieben
    if(dragMode==='moveRect'){
      const p = activePointers.get(e.pointerId);
      const dx=p.x-dragStart.mx, dy=p.y-dragStart.my;
      let L = Math.max(0, Math.min(dragStart.L + dx, stageRect.width - curW));
      let T = Math.max(0, Math.min(dragStart.T + dy, stageRect.height - curH));
      writePxAsPercent(L,T,curW,curH,stageRect);
      updateGrid();
      return;
    }
  }
  function onPointerUp(e){
    activePointers.delete(e.pointerId);
    if(activePointers.size===0){ dragMode=null; dragStart=null; }
    e.target.releasePointerCapture?.(e.pointerId);
  }

  photoStage.addEventListener('pointerdown', onPointerDown, {passive:false});
  photoStage.addEventListener('pointermove', onPointerMove, {passive:false});
  photoStage.addEventListener('pointerup', onPointerUp, {passive:false});
  photoStage.addEventListener('pointercancel', onPointerUp, {passive:false});

  photoStage.addEventListener('wheel', (e)=>{
    if(!hasImage) return; e.preventDefault();
    const factor = e.deltaY<0 ? 1.1 : 1/1.1;
    const newScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, imgScale * factor));

    const base = getBaseContainRect();
    const cx = e.clientX - photoStage.getBoundingClientRect().left;
    const cy = e.clientY - photoStage.getBoundingClientRect().top;
    const centerX = base.left + base.width/2;
    const centerY = base.top  + base.height/2;
    const px = cx - centerX, py = cy - centerY;

    const k = newScale / imgScale;
    imgOffset.x = imgOffset.x + px*(1 - k);
    imgOffset.y = imgOffset.y + py*(1 - k);
    imgScale = newScale;
    applyImgTransform();
  }, { passive:false });

  window.addEventListener('keydown', (e)=>{ if(e.code==='Space'){ spaceDown=true; photoStage.classList.add('space-pan'); } });
  window.addEventListener('keyup',   (e)=>{ if(e.code==='Space'){ spaceDown=false; photoStage.classList.remove('space-pan'); } });

  rotMinus.addEventListener('click', ()=>{ cropAngleDeg = clamp(cropAngleDeg-1, -45, 45); applyCropTransform(); });
  rotPlus .addEventListener('click', ()=>{ cropAngleDeg = clamp(cropAngleDeg+1, -45, 45); applyCropTransform(); });
  rotReset.addEventListener('click', ()=>{ cropAngleDeg = 0; applyCropTransform(); });

  window.addEventListener('resize', ()=>{
    if(hasImage) updateGrid();
    if(alignActive) (isSmall() ? show(mobileRotate) : hide(mobileRotate));
  });

  /* ========= OCR-Helfer ========= */
  function setOcrProgress(pct, text){
    ocrProgressWrap.classList.remove('d-none');
    ocrProgressBar.style.width = Math.round(pct)+'%';
    if(text) ocrStatus.textContent = text;
  }

  function preprocessRotatedToCanvas(imgEl, rectPx, angleDeg){
    const angle = angleDeg * Math.PI/180;
    const { x, y, w, h } = rectPx;
    const outW = 1500, scale = outW / w, outH = Math.round(h * scale);
    const canvas = document.createElement('canvas'); canvas.width = outW; canvas.height = outH;
    const ctx = canvas.getContext('2d');

    const base = getBaseContainRect();
    const effW = base.width * imgScale;
    const effH = base.height * imgScale;
    const effLeft = base.left + imgOffset.x + (base.width - effW)/2;
    const effTop  = base.top  + imgOffset.y + (base.height - effH)/2;

    const cx = x + w/2, cy = y + h/2;

    ctx.translate(outW/2, outH/2);
    ctx.rotate(-angle);
    ctx.scale(scale, scale);
    ctx.translate(-cx, -cy);
    ctx.imageSmoothingEnabled = true;
    ctx.drawImage(imgEl, effLeft, effTop, effW, effH);

    const id = ctx.getImageData(0,0,outW,outH);
    const d = id.data; let sum=0;
    for(let i=0;i<d.length;i+=4){ sum += 0.2126*d[i]+0.7152*d[i+1]+0.0722*d[i+2]; }
    const avg = sum/(d.length/4), gain = 1.25;
    for(let i=0;i<d.length;i+=4){
      const g = (0.2126*d[i]+0.7152*d[i+1]+0.0722*d[i+2]);
      const v = (g - avg) * gain + avg;
      d[i]=d[i+1]=d[i+2]=v; d[i+3]=255;
    }
    ctx.putImageData(id,0,0);
    return canvas;
  }

  function otsuThreshold(gray, w, h){
    const hist = new Uint32Array(256);
    for(let i=0;i<gray.length;i++) hist[gray[i]]++;
    const total=w*h; let sum=0;
    for(let t=0;t<256;t++) sum+=t*hist[t];
    let sumB=0, wB=0, varMax=-1, thr=127;
    for(let t=0;t<256;t++){
      wB += hist[t]; if(wB===0) continue;
      const wF = total - wB; if(wF===0) break;
      sumB += t*hist[t];
      const mB = sumB/wB;
      const mF = (sum - sumB)/wF;
      const between = wB*wF*(mB-mF)*(mB-mF);
      if(between>varMax){ varMax=between; thr=t; }
    }
    return thr;
  }

  function toGray(ctx, sx, sy, sw, sh){
    const id = ctx.getImageData(sx,sy,sw,sh);
    const d=id.data;
    const g=new Uint8ClampedArray(sw*sh);
    for(let i=0,j=0;i<d.length;i+=4, j++){
      g[j]=(0.2126*d[i]+0.7152*d[i+1]+0.0722*d[i+2])|0;
      d[i]=d[i+1]=d[i+2]=g[j]; d[i+3]=255;
    }
    return { id, gray:g };
  }

  function binarize(gray, w, h, mode){
    const out=new Uint8ClampedArray(w*h*4);
    const thr = mode.type==='global' ? (mode.thr ?? 128) : otsuThreshold(gray,w,h);
    for(let i=0,j=0;i<gray.length;i++,j+=4){
      let v = gray[i] > thr ? 255 : 0;
      if(mode.invert) v = 255 - v;
      out[j]=out[j+1]=out[j+2]=v; out[j+3]=255;
    }
    return out;
  }

  function paintRGBA(ctx, x, y, w, h, rgba){
    const id = ctx.createImageData(w,h);
    id.data.set(rgba);
    ctx.putImageData(id, x, y);
  }

  async function runCellOCR(bigCanvas){
    const W=bigCanvas.width, H=bigCanvas.height;
    const cw=Math.floor(W/5), ch=Math.floor(H/5);
    const results=[];
    const baseCtx=bigCanvas.getContext('2d');

    const worker = await Tesseract.createWorker('deu+eng', 1);
    await worker.setParameters({
      tessedit_char_whitelist:'0123456789',
      tessedit_do_invert:'1',
      load_system_dawg:'F',
      load_freq_dawg:'F',
      preserve_interword_spaces:'1'
    });

    let done=0, total=25;

    async function recognizeVariant(canvas, psm){
      await worker.setParameters({ tessedit_pageseg_mode: psm });
      const { data } = await worker.recognize(canvas);
      let conf=0, text=data.text||'';
      if(data && Array.isArray(data.words) && data.words.length){
        conf = data.words.reduce((a,w)=>a+w.confidence,0) / data.words.length;
      } else if(typeof data.confidence==='number'){ conf=data.confidence; }
      const m=(text||'').match(/\d{1,2}/);
      return { num: m ? parseInt(m[0],10) : null, conf: conf||0, raw:(text||'').replace(/\D+/g,'') };
    }

    function dilateBinary(arr, w, h){
      const out=new Uint8ClampedArray(arr.length);
      const idx=(x,y)=>(y*w+x)*4;
      for(let y=0;y<h;y++){
        for(let x=0;x<w;x++){
          let v=0;
          for(let dy=-1; dy<=1; dy++){
            for(let dx=-1; dx<=1; dx++){
              const nx=x+dx, ny=y+dy;
              if(nx<0||ny<0||nx>=w||ny>=h) continue;
              if(arr[idx(nx,ny)]===255){ v=255; break; }
            }
            if(v) break;
          }
          const i=idx(x,y); out[i]=out[i+1]=out[i+2]=v; out[i+3]=255;
        }
      }
      return out;
    }

    for(let r=0;r<5;r++){
      for(let c=0;c<5;c++){
        const tmp=document.createElement('canvas');
        tmp.width=cw; tmp.height=ch;
        const tctx=tmp.getContext('2d');

        const padX=Math.floor(cw*0.10), padY=Math.floor(ch*0.10);
        const sx=c*cw+padX, sy=r*ch+padY, sw=cw-2*padX, sh=ch-padY*2;

        const { id, gray } = toGray(baseCtx, sx, sy, sw, sh);

        const avg = gray.reduce((a,v)=>a+v,0)/gray.length;
        const thrGlobal = Math.max(64, Math.min(200, avg*0.92));

        const variants = [
          { type:'global', invert:false, thr:thrGlobal },
          { type:'otsu',   invert:false },
          { type:'global', invert:true, thr:255-thrGlobal }
        ];

        let best={ num:null, conf:-1, raw:'' };

        for(const mode of variants){
          const bin=binarize(gray, sw, sh, mode);
          tctx.clearRect(0,0,cw,ch);
          paintRGBA(tctx, 0,0, sw,sh, bin);
          const cand1 = await Promise.any([
            recognizeVariant(tmp, Tesseract.PSM.SINGLE_WORD),
            recognizeVariant(tmp, Tesseract.PSM.SINGLE_LINE)
          ]);
          if(cand1.conf>best.conf && cand1.num!=null){ best=cand1; }

          const dil = dilateBinary(bin, sw, sh);
          tctx.clearRect(0,0,cw,ch);
          paintRGBA(tctx, 0,0, sw,sh, dil);
          const cand2 = await Promise.any([
            recognizeVariant(tmp, Tesseract.PSM.SINGLE_WORD),
            recognizeVariant(tmp, Tesseract.PSM.SINGLE_LINE)
          ]);
          if(cand2.conf>best.conf && cand2.num!=null){ best=cand2; }
        }

        const [mn,mx] = COL_RANGES[c];
        if(best.num!=null && (best.num<mn || best.num>mx) && best.conf<60){
          best.num=null;
        }

        results.push({ num:best.num, conf:best.conf, raw:best.raw, row:r, col:c });

        done++; setOcrProgress((done/total)*100, `Erkenne Zellen… (${done}/${total})`);
        await new Promise(rq=>setTimeout(rq, 4));
      }
    }
    await worker.terminate();
    return results;
  }

  function getCropRectPixels(){
    const { L,T,W,H } = stylesToPxOnStage();
    return { x:L, y:T, w:W, h:H };
  }

  function fillInputTable(nums){
    const inputs = Array.from(inputBody.querySelectorAll('input.cell-inp'));
    inputs.forEach((inp, i)=>{
      const n = nums[i];
      if(n==null || Number.isNaN(n)){ inp.value=''; return; }
      const col = i % 5;
      const [min,max] = COL_RANGES[col];
      if(n>=min && n<=max){ inp.value = String(n); }
      else{
        inp.value=''; inp.classList.add('invalid-cell');
        setTimeout(()=>inp.classList.remove('invalid-cell'),1500);
      }
    });
    liveValidate();
  }

  async function runOCRPipeline(){
    if(!hasImage) return;
    ocrError.textContent=''; ocrSuccess.textContent=''; ocrSuccess.style.opacity='0';
    setOcrProgress(2, 'Bereite Bild vor…');
    try{
      const rectPx=getCropRectPixels();
      const prepCanvas=preprocessRotatedToCanvas(photoImage, rectPx, cropAngleDeg);
      setOcrProgress(8, 'Schneide Zellen…');

      const results = await runCellOCR(prepCanvas);
      const fixedNums = results.map((cell)=>{
        const { fixed } = (function autocorrectCell(cell){
          const DIGIT_CONFUSIONS={
            '0':['6','8'],'1':['7','4'],'2':['7'],'3':['8','5'],'4':['1','9'],
            '5':['6','3'],'6':['5','8','0'],'7':['1','2'],'8':['6','3','9','0'],'9':['8','4']
          };
          const [mn,mx]=COL_RANGES[cell.col];
          if(Number.isInteger(cell.num) && cell.num>=mn && cell.num<=mx) return { fixed:cell.num, changed:false };
          const raw = cell.raw||''; const out=new Set([raw]);
          if(raw.length===2 && raw[0]==='0') out.add(raw[1]);
          for(let i=0;i<raw.length;i++){ for(const alt of (DIGIT_CONFUSIONS[raw[i]]||[])){ out.add(raw.slice(0,i)+alt+raw.slice(i+1)); } }
          const validInCol=[], validOverall=[];
          for(const s of out){ const n=parseInt(s,10); if(!Number.isInteger(n)) continue; if(n>=1&&n<=75){ if(n>=mn&&n<=mx) validInCol.push(n); else validOverall.push(n); } }
          if(validInCol.length) return { fixed:validInCol[0], changed:true };
          if(validOverall.length) return { fixed:validOverall[0], changed:true };
          return { fixed: cell.num ?? null, changed:false };
        })(cell);
        return fixed ?? null;
      });

      fillInputTable(fixedNums);
      enableAlignUI(false);
      setOcrProgress(100, 'Fertig.');
      fadeOK(ocrSuccess, '✔️ Zahlen erkannt und eingefügt.');
      document.getElementById('top').scrollIntoView({behavior:'smooth', block:'start'});
    }catch(err){
      console.error(err);
      ocrError.textContent='❌ Konnte die Zahlen nicht zuverlässig erkennen. Bitte besser ausrichten/ausleuchten oder näher zoomen.';
    }finally{
      setTimeout(()=>{ ocrProgressWrap.classList.add('d-none'); ocrProgressBar.style.width='0%'; ocrStatus.textContent='Bereit…'; }, 1200);
    }
  }

  /* ========= Events ========= */
  saveBtn.addEventListener('click', saveCard);
  saveCancelBtn.addEventListener('click', ()=>{ exitEditMode(); clearInput(); });
  clearBtn.addEventListener('click', clearInput);
  markBtn.addEventListener('click', markNumber);
  resetBtn.addEventListener('click', resetMarks);
  inputBody.addEventListener('input', liveValidate);

  /* ========= Init ========= */
  renderAllCards();
  liveValidate();
  drawnList.textContent='Gezogene Zahlen (0): –';
  setLegendVisible(false);
  hide(toggleLegendBtn);

})();
</script>

</body>
</html>
